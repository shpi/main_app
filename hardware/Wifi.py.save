#!/usr/bin/env python3

import os
import time
import re
import threading
from subprocess import check_output, call, Popen, PIPE, DEVNULL
from PySide2.QtCore import QSettings, Qt, QModelIndex, QAbstractListModel, Property, Signal, Slot, QObject
from core.DataTypes import DataType
from hardware.System import SystemInfo
import logging
import sys


class WifiNetworkModel(QAbstractListModel):
    BSSIDRole = Qt.UserRole + 1000
    SSIDRole = Qt.UserRole + 1001
    SignalRole = Qt.UserRole + 1002
    FlagsRole = Qt.UserRole + 1003
    FrequencyRole = Qt.UserRole + 1004
    PasswordRole = Qt.UserRole + 1005

    def __init__(self, entries=[], settings: QSettings = None, active='', parent=None):
        super(WifiNetworkModel, self).__init__(parent)
        self._entries = entries
        self.settings = settings

    def rowCount(self, parent=QModelIndex()):
        if parent.isValid():
            return 0
        return len(self._entries)

    def data(self, index, role=Qt.DisplayRole):
        if 0 <= index.row() < self.rowCount() and index.isValid():
            item = self._entries[index.row()]
            if role == WifiNetworkModel.BSSIDRole:
                return item[b"bssid"]
            elif role == WifiNetworkModel.SSIDRole:
                return item[b"ssid"]
            elif role == WifiNetworkModel.SignalRole:
                return Wifi.dbmtoperc[int(item[b"signal"])]
            elif role == WifiNetworkModel.FlagsRole:
                if 'WPA2' in item[b'flags']:
                    return 'WPA2'
                elif 'WPA' in item[b'flags']:
                    return 'WPA'
                elif 'WEP' in item[b'flags']:
                    return 'WEP'
                else:
                    return 'OPEN'
            elif role == WifiNetworkModel.PasswordRole:
                return self.settings.value("wifi/password/" + item[b"bssid"], "")

            elif role == WifiNetworkModel.FrequencyRole:
                if int(item[b"frequency"]) in Wifi.freqtochn:
                    return Wifi.freqtochn[int(item[b"frequency"])]
                else:
                    return item[b"frequency"]

    def roleNames(self):

        roles = {WifiNetworkModel.BSSIDRole: b"bssid",
                 WifiNetworkModel.SSIDRole: b"ssid",
                 WifiNetworkModel.FlagsRole: b"flags",
                 WifiNetworkModel.SignalRole: b"signal",
                 WifiNetworkModel.PasswordRole: b"password",
                 WifiNetworkModel.FrequencyRole: b"frequency"}

        return roles

    def appendRow(self, n):
        self.beginInsertRows(QModelIndex(), self.rowCount(), self.rowCount())
        self._entries.append(n)
        self.endInsertRows()


class Wifi(QObject):

    def __init__(self, settings):

        super(Wifi, self).__init__()
        self.settings = settings
        self.wpa_running = True
        self.inputs = dict()
        self.netdevs = SystemInfo.get_net_devs() #wlan0, wlan1
        self._network_hosts = dict()
        self.wifi_devices = []
        self._networks = WifiNetworkModel([], self.settings)
        self.signals = dict()
        self.read_signal()

        for device in self.netdevs:
            if device.startswith('wlan'):
                self.scan_wifi(device)

        self.start_scan_hosts()

    @Slot()
    def start_scan_hosts(self):

        for netdev in self.netdevs:
            if netdev != 'lo':
                threading.Thread(target=self.scan_hosts, args=(netdev,)).start()


    #def update(self):
        #self.read_signal()

    def get_inputs(self) -> dict:
        return self.inputs


    @Signal
    def hostsChanged(self):
        pass


    def scan_hosts(self, device):
      try:

        p = Popen(['nmap', '-sn', str(SystemInfo.get_ip4_address(device))+'/24'], stdout=PIPE, stdin=PIPE, stderr=PIPE)
        #'sudo', '-S',
        #stdout_data = p.communicate(input=b'password')[0].split(b'\n')
        stdout_data = p.communicate()[0].split(b'\n')

        found_hosts =  list(self._network_hosts.keys())

        for key in found_hosts:

            if 'dev' in self._network_hosts[key]: # because helper list in dictionary for qml
                if self._network_hosts[key]['dev'] == device:
                    del self._network_hosts[key]

        for line in stdout_data:
            output = re.search(b'Nmap scan report for ([^ ]*) \(([^\)]*)\)', line)
            if output:
                    ip = output.group(2).decode()
                    self._network_hosts[ip] = {'ip':ip, 'hostname':output.group(1).decode(), 'dev' : device}
            else:
                output = re.search(b'Nmap scan report for ([^\n]*)', line)
                if output:
                    ip = output.group(1).decode()
                    self._network_hosts[ip] = {'ip': ip, 'dev' : device}
            output = re.search(b'Host is up \(([^ ]*) latency\)', line)
            if output:
                self._network_hosts[ip]['latency'] = output.group(1).decode()
            output = re.search(b'MAC Address: ([^ ]*) \(([^\)]*)\)', line)
            if output:
                self._network_hosts[ip]['mac'] = output.group(1).decode()
                self._network_hosts[ip]['manufacturer'] = output.group(2).decode()
        self.hostsChanged.emit()
      except Exception as e:
          logging.error(str(e))


    @Property('QVariantMap', notify=hostsChanged)
    def network_hosts(self):
        if 'list' in self._network_hosts:
            del self._network_hosts['list']
        self._network_hosts['list'] = list(self._network_hosts.keys())
        return (self._network_hosts)

    @Signal
    def devicesChanged(self):
        pass

    @Property('QVariantList', notify=devicesChanged)
    def devices(self):
        return self.netdevs


    @Signal
    def networksChanged(self):
        pass

    @Property(QObject, notify=networksChanged)
    def networks(self):
        return self._networks

    @Slot()
    @Slot(str)
    def scan_wifi(self, ignore=None): #fix later
        logging.info('scan wifi status: '  + str(ignore))
        self.netdevs = SystemInfo.get_net_devs()
        self.devicesChanged.emit()

        if len(self.netdevs) > 0:

          for device in self.netdevs:
              if device.startswith('wlan'):
                  scanthread = threading.Thread(target=self._scan_wifi, args=(device,))
                  scanthread.start()

    def _scan_wifi(self, device):
        networks = []

        retry = 3
        while retry > 0:
            try:
                if b'OK' in check_output(["wpa_cli", "-i", device, "scan"], stderr=DEVNULL):
                    retry = 0

                    record_details = Popen(["wpa_cli", "-i", device, "scan_results"], stdout=PIPE).communicate()[0].decode()
                    record_details = record_details.strip().split('\n')
                    record_details.pop(0)

                    for record in record_details:
                        record = record.split('\t')
                        if len(record) < 5:
                            record.append('')
                        networks.append({b'device': device, b'bssid': record[0],
                                         b'frequency': record[1], b'signal': record[2].rstrip('.'),
                                         b'flags': record[3], b'ssid': record[4]})

                else:
                    time.sleep(0.3)
                    retry -= 1
            except Exception as e:
                retry -= 1
                exception_type, exception_object, exception_traceback = sys.exc_info()
                line_number = exception_traceback.tb_lineno
                logging.error('error: {}'.format(e))
                logging.error('error in line: {}'.format(line_number))
        self._networks = WifiNetworkModel(networks, self.settings)
        self.networksChanged.emit()

    @Slot(str, result=str)
    def wpa_status(self, device):
        if not self.wpa_running:
            return 'WPA reinit'

        try:
         output = check_output(
            ['wpa_cli', '-i', device, 'status']).split(b'\n')
         logging.error(str(output))
         for line in output:
            if line.startswith(b'wpa_state='):
                return line[10:].rstrip().decode()
            if line.startswith(b'bssid='):
                self.connected_bssid = line[6:].rstrip().decode()
        except Exception as e:
            exception_type, exception_object, exception_traceback = sys.exc_info()
            line_number = exception_traceback.tb_lineno
            logging.error('error: {}'.format(e))
            logging.error('error in line: {}'.format(line_number))

        return 'UNKNOWN'

    @Slot(str, result=str)
    def signal_status(self, device):

        return str(self.signals[device])



    @Slot(str, str, str, str, str, bool)
    def write_settings(self, device='', flags='', bssid='', ssid='', passwd='', fixbssid=False):
                  scanthread = threading.Thread(target=self._write_settings, args=(device,flags,bssid,ssid,passwd,fixbssid))
                  scanthread.start()


    #@Slot(str, str, str, str, str, bool)
    def _write_settings(self, device='', flags='', bssid='', ssid='', passwd='', fixbssid=False):
       try:
        self.wpa_running = False

        self.settings.setValue("wifi/password/" + bssid, passwd)
        with open('/etc/wpa_supplicant/wpa_supplicant.conf', 'w') as f:

            f.write('ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\n')
            f.write('update_config=1\n')
            f.write('country=US\n')
            f.write('network={\n')
            f.write('ssid="' + ssid + '"\n')
            if fixbssid:
                f.write('bssid=' + bssid + '\n')
            if 'ssid' == '':
                f.write('scan_ssid=1\n')

            if 'WPA2' in flags:
                f.write('psk="' + passwd + '"\n')
            elif 'WEP' in flags:
                f.write('wep_tx_keyidx=0\n')
                f.write('wep_key0="' + passwd + '"\n')
                f.write('key_mgmt=NONE\n')
            elif 'WPA' in flags:
                f.write('psk="' + passwd + '"\n')
                f.write('pairwise=CCMP\n')
                f.write('group=TKIP\n')
            else:
                f.write('key_mgmt=NONE\n')

            f.write('}')
            p = Popen(['wpa_cli', '-i', device, 'reconfigure'], shell=False, stdin=None, stdout=PIPE, stderr=PIPE)
            data = p.communicate()
            logging.error(data[0])
            logging.error(data[1])
            logging.error(check_output(['systemctl', '', 'wpa_supplicant@wlan0.service'], encoding='UTF-8'))
            logging.error(check_output(['systemctl', 'restart', 'dhcpcd.service'], encoding='UTF-8'))
            self.wpa_running = True

       except Exception as e:
             logging.error(str(e))

    def read_signal(self):
        logging.debug('read signal called')
        self.new_devices = list()
        if os.path.isfile('/proc/net/wireless'):
            with open('/proc/net/wireless', 'r') as rf:
                line = rf.readline()
                while line:
                    line = (rf.readline().rstrip().split())
                    if line and line[0].startswith('wlan'):
                        device = line[0].rstrip(":")
                        if device not in self.wifi_devices:
                            self.wifi_devices.append(device)
                        self.new_devices.append(device)
                        if f'wifi/{device}/link' not in self.inputs:
                            self.inputs[f'wifi/{device}/link'] = {'description': f'link quality of device {line[0].rstrip(":")}',
                                                                  'interval': 1, 'lastupdate': 0, 'call': self.read_signal}
                        self.signals[device] = self.dbmtoperc[int(
                            line[3].rstrip('.'))]
                        self.inputs[f'wifi/{device}/link']['value'] = self.signals[device]

                        self.inputs[f'wifi/{device}/link']['status'] = line[1]
                        self.inputs[f'wifi/{device}/link']['quality'] = line[2]
                        self.inputs[f'wifi/{device}/link']['noise'] = line[4]
                        self.inputs[f'wifi/{device}/link']['type'] = DataType.PERCENT_INT
                        self.inputs[f'wifi/{device}/link']['lastupdate'] = time.time()


            for device in self.wifi_devices:  # reset values before checking
                if device not in self.new_devices:
                    self.inputs[f'wifi/{device}/link']['value'] = 0
                    self.inputs[f'wifi/{device}/link']['status'] = 0
                    self.inputs[f'wifi/{device}/link']['level'] = 0
                    self.inputs[f'wifi/{device}/link']['noise'] = 0
                    self.inputs[f'wifi/{device}/link']['lastupdate'] = time.time()

            self.devicesChanged.emit()

    dbmtoperc = {-1: 100,  -26: 98, -51: 78, -76: 38,
                 -2: 100,  -27: 97, -52: 76, -77: 36,
                 -3: 100,  -28: 97, -53: 75, -78: 34,
                 -4: 100,  -29: 96, -54: 74, -79: 32,
                 -5: 100,  -30: 96, -55: 73, -80: 30,
                 -6: 100,  -31: 95, -56: 71, -81: 28,
                 -7: 100,  -32: 95, -57: 70, -82: 26,
                 -8: 100,  -33: 94, -58: 69, -83: 24,
                 -9: 100,  -34: 93, -59: 67, -84: 22,
                 -10: 100, -35: 93, -60: 66, -85: 20,
                 -11: 100, -36: 92, -61: 64, -86: 17,
                 -12: 100, -37: 91, -62: 63, -87: 15,
                 -13: 100, -38: 90, -63: 61, -88: 13,
                 -14: 100, -39: 90, -64: 60, -89: 10,
                 -15: 100, -40: 89, -65: 58, -90: 8,
                 -16: 100, -41: 88, -66: 56, -91: 6,
                 -17: 100, -42: 87, -67: 55, -92: 3,
                 -18: 100, -43: 86, -68: 53, -93: 1,
                 -19: 100, -44: 85, -69: 51, -94: 1,
                 -20: 100, -45: 84, -70: 50, -95: 1,
                 -21: 99,  -46: 83, -71: 48, -96: 1,
                 -22: 99,  -47: 82, -72: 46, -97: 1,
                 -23: 99,  -48: 81, -73: 44, -98: 1,
                 -24: 98,  -49: 80, -74: 42, -99: 1,
                 -25: 98,  -50: 79, -75: 40, -100: 1}

    freqtochn = {2412: '2.4GHz 1', 2417: '2.4GHz 2',
                 2422: '2.4GHz 3', 2427: '2.4GHz 4',
                 2432: '2.4GHz 5', 2437: '2.4GHz 6',
                 2442: '2.4GHz 7', 2447: '2.4GHz 8',
                 2452: '2.4GHz 9', 2457: '2.4GHz 10',
                 2462: '2.4GHz 11', 2467: '2.4GHz 12',
                 2472: '2.4GHz 13', 2484: '2.4GHz 14',
                 5035: '5GHz 7', 5040: '5GHz 8',
                 5045: '5GHz 9', 5055: '5GHz 11',
                 5060: '5GHz 12', 5080: '5GHz 16',
                 5160: '5GHz 32', 5170: '5GHz 34',
                 5180: '5GHz 36', 5190: '5GHz 38',
                 5200: '5GHz 40', 5210: '5GHz 42',
                 5220: '5GHz 44', 5230: '5GHz 46',
                 5240: '5GHz 48', 5250: '5GHz 50',
                 5260: '5GHz 52', 5270: '5GHz 54',
                 5280: '5GHz 56', 5290: '5GHz 58',
                 5300: '5GHz 60', 5310: '5GHz 62',
                 5320: '5GHz 64', 5340: '5GHz 68',
                 5480: '5GHz 96', 5500: '5GHz 100',
                 5510: '5GHz 102', 5520: '5GHz 104',
                 5530: '5GHz 106', 5540: '5GHz 108',
                 5550: '5GHz 110', 5560: '5GHz 112',
                 5570: '5GHz 114', 5580: '5GHz 116',
                 5590: '5GHz 118', 5600: '5GHz 120',
                 5610: '5GHz 122', 5620: '5GHz 124',
                 5630: '5GHz 126', 5640: '5GHz 128',
                 5660: '5GHz 132', 5670: '5GHz 134',
                 5680: '5GHz 136', 5690: '5GHz 138',
                 5700: '5GHz 140', 5710: '5GHz 142',
                 5720: '5GHz 144', 5745: '5GHz 149',
                 5755: '5GHz 151', 5765: '5GHz 153',
                 5775: '5GHz 155', 5785: '5GHz 157',
                 5795: '5GHz 159', 5805: '5GHz 161',
                 5825: '5GHz 165', 5845: '5GHz 169',
                 5865: '5GHz 173', 4915: '5GHz 183',
                 4920: '5GHz 184', 4925: '5GHz 185',
                 4935: '5GHz 187', 4940: '5GHz 188',
                 4945: '5GHz 189', 4960: '5GHz 192',
                 4980: '5GHz 196'}
